// Integration Generator - The Brain

import { loadIntegrationTemplates, loadIntegrationReadme, loadIntegrationSchema } from "./fileLoader.js";
import { mapTemplateToPath, mapFromSchema, mapEnvToPath } from "./pathMap.js";
import { getIntegration, loadRegistry } from "./registry.js";
import { generateEnvExample, generateEnvForIntegration } from "./envBuilder.js";

export interface GeneratedFile {
  integration: string;
  template: string;
  path: string;
  content: string;
  type: "file" | "env" | "doc";
}

export async function generateFilesForIntegrations(
  selected: string[]
): Promise<GeneratedFile[]> {
  const output: GeneratedFile[] = [];
  const registry = loadRegistry();

  console.log(`[Generator] Generating files for: ${selected.join(", ")}`);

  for (const name of selected) {
    // Validate integration exists
    if (!registry[name]) {
      console.warn(`[Generator] Unknown integration: ${name}, skipping`);
      continue;
    }

    const integration = getIntegration(name);
    const templates = loadIntegrationTemplates(name);
    const schema = loadIntegrationSchema(name);

    console.log(`[Generator] Processing ${name}: ${templates.length} templates`);

    // Process each template file
    for (const t of templates) {
      // Check schema for custom output path first
      let repoPath = mapFromSchema(name, t.templateName, schema);

      // Fall back to default path mapping
      if (!repoPath) {
        repoPath = mapTemplateToPath(name, t.templateName);
      }

      output.push({
        integration: name,
        template: t.templateName,
        path: repoPath,
        content: t.content,
        type: "file",
      });
    }

    // Add env file for this integration
    if (integration.env && integration.env.length > 0) {
      output.push({
        integration: name,
        template: "env",
        path: mapEnvToPath(name),
        content: generateEnvForIntegration(name),
        type: "env",
      });
    }

    // Add readme if exists
    const readme = loadIntegrationReadme(name);
    if (readme) {
      output.push({
        integration: name,
        template: "readme",
        path: `docs/integrations/${name}/README.md`,
        content: readme,
        type: "doc",
      });
    }
  }

  // Add combined .env.example at root
  output.push({
    integration: "core",
    template: "env.example",
    path: ".env.example",
    content: generateEnvExample(selected),
    type: "env",
  });

  // Add integrations index file
  output.push({
    integration: "core",
    template: "index",
    path: "src/integrations/index.ts",
    content: generateIndexFile(selected),
    type: "file",
  });

  console.log(`[Generator] Total files generated: ${output.length}`);
  return output;
}

// Generate index file that exports all integrations
function generateIndexFile(integrations: string[]): string {
  const exports = integrations
    .map((name) => {
      const camelName = toCamelCase(name);
      return `export * as ${camelName} from "./${name}";`;
    })
    .join("\n");

  return `// Auto-generated by AutoIntegrate
// Integrations: ${integrations.join(", ")}
// Generated at: ${new Date().toISOString()}

${exports}
`;
}

// Convert kebab-case to camelCase
function toCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

// Get summary of what will be generated
export function getGenerationSummary(selected: string[]): {
  totalFiles: number;
  byIntegration: Record<string, number>;
  envVars: string[];
} {
  const registry = loadRegistry();
  const byIntegration: Record<string, number> = {};
  let totalFiles = 0;
  const envVars: string[] = [];

  for (const name of selected) {
    if (!registry[name]) continue;

    const templates = loadIntegrationTemplates(name);
    byIntegration[name] = templates.length;
    totalFiles += templates.length;

    const integration = getIntegration(name);
    if (integration.env) {
      envVars.push(...integration.env);
    }
  }

  // Add core files
  totalFiles += 2; // index.ts + .env.example

  return {
    totalFiles,
    byIntegration,
    envVars: [...new Set(envVars)],
  };
}
